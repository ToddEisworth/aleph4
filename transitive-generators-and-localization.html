<!DOCTYPE html>
<!--********************************************-->
<!--*       Generated from PreTeXt source      *-->
<!--*                                          *-->
<!--*         https://pretextbook.org          *-->
<!--*                                          *-->
<!--********************************************-->
<html lang="en-US" dir="ltr">
<head xmlns:og="http://ogp.me/ns#" xmlns:book="https://ogp.me/ns/book#">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Transitive Generators and Localization</title>
<meta name="Keywords" content="Authored in PreTeXt">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta property="og:type" content="article">
<script>
var runestoneMathReady = new Promise((resolve) => window.rsMathReady = resolve);
window.MathJax = {
  "tex": {
    "inlineMath": [
      [
        "\\(",
        "\\)"
      ]
    ],
    "tags": "none",
    "tagSide": "right",
    "tagIndent": ".8em",
    "packages": {
      "[+]": [
        "base",
        "extpfeil",
        "ams",
        "amscd",
        "color",
        "newcommand",
        "knowl"
      ]
    }
  },
  "options": {
    "ignoreHtmlClass": "tex2jax_ignore|ignore-math",
    "processHtmlClass": "process-math"
  },
  "chtml": {
    "scale": 0.98,
    "mtextInheritFont": true
  },
  "loader": {
    "load": [
      "input/asciimath",
      "[tex]/extpfeil",
      "[tex]/amscd",
      "[tex]/color",
      "[tex]/newcommand",
      "[pretext]/mathjaxknowl3.js"
    ],
    "paths": {
      "pretext": "https://pretextbook.org/js/lib"
    }
  },
  "startup": {
    pageReady() {
      return MathJax.startup.defaultPageReady().then(function () {
      console.log("in ready function");
      rsMathReady();
      }
    )}
  }
};
</script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/lunr.js/2.3.9/lunr.min.js" integrity="sha512-4xUl/d6D6THrAnXAwGajXkoWaeMNwEKK4iNfq5DotEbLPAfk6FSxSP3ydNxqDgCw1c/0Z1Jg6L8h2j+++9BZmg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script><script src="lunr-pretext-search-index.js" async=""></script><script src="https://pretextbook.org/js/0.33/pretext_search.js"></script><link href="https://pretextbook.org/css/0.83/pretext_search.css" rel="stylesheet" type="text/css">
<script>js_version = 0.33</script><script src="https://pretextbook.org/js/lib/jquery.min.js"></script><script src="https://pretextbook.org/js/lib/jquery.sticky.js"></script><script src="https://pretextbook.org/js/lib/jquery.espy.min.js"></script><script src="https://pretextbook.org/js/0.33/pretext.js"></script><script>miniversion=0.1</script><script src="https://pretextbook.org/js/0.33/pretext_add_on.js?x=1"></script><script src="https://pretextbook.org/js/0.33/user_preferences.js"></script><script src="https://pretextbook.org/js/lib/knowl.js"></script><!--knowl.js code controls Sage Cells within knowls--><script>sagecellEvalName='Evaluate (Sage)';
</script><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
<link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&amp;family=Noto+Serif:ital,wght@0,400;0,700;1,400;1,700&amp;family=Tinos:ital,wght@0,400;0,700;1,400;1,700&amp;display=swap" rel="stylesheet">
<link href="https://fonts.cdnfonts.com/css/dejavu-serif" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Roboto+Serif:opsz,wdth,wght@8..144,50..150,100..900&amp;display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Open+Sans:wdth,wght@75..100,300..800&amp;display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200">
<link href="https://pretextbook.org/css/0.83/pretext.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/pretext_add_on.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/shell_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/banner_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/navbar_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/toc_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/knowls_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/style_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/colors_default.css" rel="stylesheet" type="text/css">
<link href="https://pretextbook.org/css/0.83/setcolors.css" rel="stylesheet" type="text/css">
</head>
<body class="pretext article ignore-math">
<a class="assistive" href="#ptx-content">Skip to main content</a><header id="ptx-masthead" class="ptx-masthead"><div class="ptx-banner">
<a id="logo-link" class="logo-link" target="_blank" href=""></a><div class="title-container">
<h1 class="heading"><a href="my-great-article.html"><span class="title">blah</span></a></h1>
<p class="byline"></p>
</div>
</div></header><nav id="ptx-navbar" class="ptx-navbar navbar"><button class="toc-toggle button" title="Contents"><span class="icon material-symbols-outlined" aria-hidden="true">&#xe5d2;</span><span class="name">Contents</span></button><div class="searchbox">
<div class="searchwidget"><button id="searchbutton" class="searchbutton button" type="button" title="Search book"><span class="icon material-symbols-outlined" aria-hidden="true">&#xe8b6;</span><span class="name">Search Book</span></button></div>
<div id="searchresultsplaceholder" class="searchresultsplaceholder" style="display: none">
<div class="search-results-controls">
<input aria-label="Search term" id="ptxsearch" class="ptxsearch" type="text" name="terms" placeholder="Search term"><button title="Close search" id="closesearchresults" class="closesearchresults"><span class="material-symbols-outlined">close</span></button>
</div>
<h2 class="search-results-heading">Search Results: </h2>
<div id="searchempty" class="searchempty"><span>No results.</span></div>
<ol id="searchresults" class="searchresults"></ol>
</div>
</div>
<span class="nav-other-controls"></span><span class="treebuttons"><a class="previous-button button" href="things-we-already-know.html" title="Previous"><span class="icon material-symbols-outlined" aria-hidden="true">&#xe5cb;</span><span class="name">Prev</span></a><a class="up-button button" href="my-great-article.html" title="Up"><span class="icon material-symbols-outlined" aria-hidden="true">&#xe5ce;</span><span class="name">Up</span></a><a class="next-button button" href="no-large-intervals.html" title="Next"><span class="name">Next</span><span class="icon material-symbols-outlined" aria-hidden="true">&#xe5cc;</span></a></span></nav><div id="latex-macros" class="hidden-content process-math" style="display:none"><span class="process-math">\(\newcommand{\foo}{b^{ar}}
\newcommand{\lt}{&lt;}
\newcommand{\gt}{&gt;}
\newcommand{\amp}{&amp;}
\definecolor{fillinmathshade}{gray}{0.9}
\newcommand{\fillinmath}[1]{\mathchoice{\colorbox{fillinmathshade}{$\displaystyle     \phantom{\,#1\,}$}}{\colorbox{fillinmathshade}{$\textstyle        \phantom{\,#1\,}$}}{\colorbox{fillinmathshade}{$\scriptstyle      \phantom{\,#1\,}$}}{\colorbox{fillinmathshade}{$\scriptscriptstyle\phantom{\,#1\,}$}}}
\)</span></div>
<div class="ptx-page">
<div id="ptx-sidebar" class="ptx-sidebar"><nav id="ptx-toc" class="ptx-toc depth2"><ul class="structural contains-active toc-item-list">
<li class="toc-item toc-section">
<div class="toc-title-box"><a href="the-basic-pcf-toolkit.html" class="internal"><span class="codenumber">1</span> <span class="title">The basic pcf toolkit</span></a></div>
<ul class="structural toc-item-list">
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="the-basic-pcf-toolkit.html#what-is-mathopmathrmpcfa-again" class="internal"><span class="codenumber">1.1</span> <span class="title">What is <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\)</span> again?</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="the-basic-pcf-toolkit.html#what-about-those-ideals-and-generator-things" class="internal"><span class="codenumber">1.2</span> <span class="title">What about those ideals and generator things?</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="the-basic-pcf-toolkit.html#compactness-for-generators" class="internal"><span class="codenumber">1.3</span> <span class="title">Compactness for Generators</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="the-basic-pcf-toolkit.html#the-ideals-j_lambdaa" class="internal"><span class="codenumber">1.4</span> <span class="title">The ideals <span class="process-math">\(J_{&lt;\lambda}[A]\)</span></span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="the-basic-pcf-toolkit.html#cofinality-sequences" class="internal"><span class="codenumber">1.5</span> <span class="title">Cofinality sequences</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="the-basic-pcf-toolkit.html#what-do-we-mean-by-pcf-structure" class="internal"><span class="codenumber">1.6</span> <span class="title">What do we mean by “pcf structure”?</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="the-basic-pcf-toolkit.html#application-the-cofinality-of-prod-a" class="internal"><span class="codenumber">1.7</span> <span class="title">Application: the cofinality of <span class="process-math">\(\prod A\)</span></span></a></div></li>
</ul>
</li>
<li class="toc-item toc-section">
<div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html" class="internal"><span class="codenumber">2</span> <span class="title">Characteristic Functions and <span class="process-math">\(\mathop{\mathrm{cf}}\left([\aleph_\omega]^{\aleph_0},\subseteq\right)\)</span></span></a></div>
<ul class="structural toc-item-list">
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html#internally-approachable-models" class="internal"><span class="codenumber">2.1</span> <span class="title">Internally Approachable Models</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html#characteristic-functions-of-models" class="internal"><span class="codenumber">2.2</span> <span class="title">Characteristic functions of models</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html#building-generators-from-cofinality-sequences" class="internal"><span class="codenumber">2.3</span> <span class="title">Building generators from cofinality sequences</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html#minimal-club-continuity" class="internal"><span class="codenumber">2.4</span> <span class="title">Minimal club continuity</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html#internal-reflections" class="internal"><span class="codenumber">2.5</span> <span class="title">Internal reflections</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html#characterizing-characteristic-functions" class="internal"><span class="codenumber">2.6</span> <span class="title">Characterizing characteristic functions</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="characteristic-functions-and-mathopmathrmcfleftaleph_omegaaleph_0subseteqright.html#the-cofinality-of-aleph_omegaaleph_0subseteq" class="internal"><span class="codenumber">2.7</span> <span class="title">The cofinality of <span class="process-math">\(([\aleph_\omega]^{\aleph_0},\subseteq)\)</span></span></a></div></li>
</ul>
</li>
<li class="toc-item toc-section">
<div class="toc-title-box"><a href="things-we-already-know.html" class="internal"><span class="codenumber">3</span> <span class="title">Things we already know(?)</span></a></div>
<ul class="structural toc-item-list">
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="things-we-already-know.html#no-holes-theorem" class="internal"><span class="codenumber">3.1</span> <span class="title">No Holes Theorem</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="things-we-already-know.html#scales-at-cardinals-of-uncountable-cofinality" class="internal"><span class="codenumber">3.2</span> <span class="title">Scales at cardinals of uncountable cofinality</span></a></div></li>
</ul>
</li>
<li class="toc-item toc-section active">
<div class="toc-title-box"><a href="transitive-generators-and-localization.html" class="internal"><span class="codenumber">4</span> <span class="title">Transitive Generators and Localization</span></a></div>
<ul class="structural toc-item-list">
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="transitive-generators-and-localization.html#what-are-transitive-generators" class="internal"><span class="codenumber">4.1</span> <span class="title">What are transitive generators?</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="transitive-generators-and-localization.html#a-naive-attempt" class="internal"><span class="codenumber">4.2</span> <span class="title">A naive attempt</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="transitive-generators-and-localization.html#existence-of-transitive-generators" class="internal"><span class="codenumber">4.3</span> <span class="title">Existence of Transitive Generators</span></a></div></li>
<li class="toc-item toc-subsection"><div class="toc-title-box"><a href="transitive-generators-and-localization.html#the-localization-theorem" class="internal"><span class="codenumber">4.4</span> <span class="title">The Localization Theorem</span></a></div></li>
</ul>
</li>
<li class="toc-item toc-section"><div class="toc-title-box"><a href="no-large-intervals.html" class="internal"><span class="codenumber">5</span> <span class="title">No large intervals</span></a></div></li>
</ul></nav></div>
<main class="ptx-main"><div id="ptx-content" class="ptx-content"><section class="section" id="transitive-generators-and-localization"><h2 class="heading hide-type">
<span class="type">Section</span><span class="space"> </span><span class="codenumber">4</span><span class="space"> </span><span class="title">Transitive Generators and Localization</span>
</h2>
<div class="para" id="transitive-generators-and-localization-2"><em class="emphasis">Notes were typed some time ago, so need to be smoothed out. They may repeat some things we did last week.</em></div>
<section class="subsection" id="what-are-transitive-generators"><h3 class="heading hide-type">
<span class="type">Subsection</span><span class="space"> </span><span class="codenumber">4.1</span><span class="space"> </span><span class="title">What are transitive generators?</span>
</h3>
<div class="para logical" id="what-are-transitive-generators-2">
<div class="para">
<dfn class="terminology">Definition 19</dfn>.  Suppose <span class="process-math">\(A\subseteq\mathop{\mathrm{{\sf REG}}}\)</span> is progressive, and <span class="process-math">\(\Lambda\)</span> is a subset of <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\text{.}\)</span> Let <span class="process-math">\(\bar{B}\)</span> be a sequence <span class="process-math">\(\langle
B_\lambda:\lambda\in\Lambda\rangle\)</span> of generators for <span class="process-math">\(\Lambda\)</span> in <span class="process-math">\(A\text{.}\)</span> We say <span class="process-math">\(\bar{B}\)</span> is <em class="emphasis">transitive</em> if</div>
<div class="displaymath process-math">
\begin{equation*}
\lambda\in\Lambda\text{ and }\theta\in B_\lambda\cap\Lambda\Longrightarrow B_\theta\subseteq B_\lambda.
\end{equation*}
</div>
</div>
<div class="para" id="what-are-transitive-generators-3">Suppose we are given a set <span class="process-math">\(\Lambda\)</span> with <span class="process-math">\(A\subseteq\Lambda\subseteq\mathop{\mathrm{pcf}}(A)\)</span> together with a corresponding sequence <span class="process-math">\(\langle
B_\lambda:\lambda\in\Lambda\rangle\)</span> of generators for each <span class="process-math">\(\lambda\in\Lambda\)</span> in <span class="process-math">\(A\text{.}\)</span> How would one go converting this sequence of generators into a transitive one? The first thing we try is brute force.</div></section><section class="subsection" id="a-naive-attempt"><h3 class="heading hide-type">
<span class="type">Subsection</span><span class="space"> </span><span class="codenumber">4.2</span><span class="space"> </span><span class="title">A naive attempt</span>
</h3>
<div class="para" id="a-naive-attempt-2">Let us assume that <span class="process-math">\(\langle B_\lambda:\lambda\in\Lambda\rangle\)</span> is a sequence of generators for some subset <span class="process-math">\(\Lambda\)</span> of <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\text{.}\)</span> We now try the obvious thing to convert this sequence into a transitive one.</div>
<div class="para" id="a-naive-attempt-3">By induction on <span class="process-math">\(n&lt;\omega\text{,}\)</span> we define sets <span class="process-math">\(B^n_\lambda\)</span> for <span class="process-math">\(\lambda\in\Lambda\)</span> according to the following recipe:</div>
<div class="para logical" id="a-naive-attempt-4"><ul class="disc">
<li id="a-naive-attempt-4-1-1"><div class="para" id="a-naive-attempt-4-1-1-1"><span class="process-math">\(\displaystyle B^0_\lambda = B_\lambda\)</span></div></li>
<li id="a-naive-attempt-4-1-2"><div class="para" id="a-naive-attempt-4-1-2-1"><span class="process-math">\(\displaystyle B^{n+1}_\lambda = B^n_\lambda\cup\bigcup\{B^n_\theta:\theta\in B^n_\lambda\}\)</span></div></li>
</ul></div>
<div class="para logical" id="a-naive-attempt-5">
<div class="para">Finally, let</div>
<div class="displaymath process-math">
\begin{equation*}
B^\dagger_\lambda = \bigcup_{n&lt;\omega}B^n_\lambda.
\end{equation*}
</div>
<div class="para">We call the collection <span class="process-math">\(\langle B^\dagger_\lambda:\lambda\in\Lambda\rangle\)</span> the <em class="emphasis">smoothing</em> of <span class="process-math">\(\langle
B_\lambda:\lambda\in\Lambda\rangle\text{.}\)</span>
</div>
</div>
<div class="para logical" id="a-naive-attempt-6">
<div class="para">Notice that the smoothing of <span class="process-math">\(\langle B_\lambda:\lambda\in\Lambda\rangle\)</span> is transitive: if <span class="process-math">\(\theta\in B^\dagger_\lambda\)</span> then <span class="process-math">\(\theta\in B^n_\lambda\)</span> for some <span class="process-math">\(n\text{,}\)</span> and then our construction guarantees</div>
<div class="displaymath process-math">
\begin{equation*}
n\leq k&lt;\omega\Longrightarrow B^k_\theta\subseteq B^{k+1}_\lambda,
\end{equation*}
</div>
<div class="para">so <span class="process-math">\(B^\dagger_\theta\subseteq B^\dagger_\lambda\text{.}\)</span>
</div>
</div>
<div class="para" id="a-naive-attempt-7">What could go wrong? We have no way of knowing that <span class="process-math">\(B^\dagger_\lambda\)</span> is still a generator for <span class="process-math">\(\lambda\text{,}\)</span> as the smoothing process may have enlarged it too much. We need some way of guaranteeing that <span class="process-math">\(\max\mathop{\mathrm{pcf}}(B^\dagger_\lambda)\)</span> is still <span class="process-math">\(\lambda\text{.}\)</span> This is where the work in the previous section will pay off, as we will be able to show that the smoothing process will work with the sort of generators we built there. To refresh our memory, we review the notational complexity concerning generators that has accumulated over this section and the preceding one.</div>
<div class="para" id="a-naive-attempt-8">First, in the model <span class="process-math">\(N_0\)</span> we have a fixed set of generators <span class="process-math">\(\langle B_\lambda:\lambda\in\mathop{\mathrm{pcf}}(A)\rangle\)</span> as well as corresponding cofinality sequences <span class="process-math">\(\bar{f}^\lambda\)</span> for each <span class="process-math">\(\lambda\in\mathop{\mathrm{pcf}}(A)\text{,}\)</span> which we assume to be minimally club continuous on cofinality <span class="process-math">\(\kappa\text{.}\)</span>
</div>
<div class="para logical" id="a-naive-attempt-9">
<div class="para">For each <span class="process-math">\(\lambda\)</span> in <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(A)\text{,}\)</span> the cofinality sequence <span class="process-math">\(\bar{f}^\lambda\)</span> produces a generator <span class="process-math">\(B^*_\lambda\)</span> for <span class="process-math">\(\lambda\)</span> defined as</div>
<div class="displaymath process-math">
\begin{equation*}
B^*_\lambda = \left\{a\in A: f^\lambda_{\sup(N\cap\lambda)}(a)=\sup(N\cap a)\right\}.
\end{equation*}
</div>
<div class="para">There is also a closed unbounded set <span class="process-math">\(E\subseteq\kappa\)</span> with the property that for each <span class="process-math">\(\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\text{,}\)</span> for all sufficiently large <span class="process-math">\(i&lt;j\)</span> in <span class="process-math">\(E\text{,}\)</span> the set</div>
<div class="displaymath process-math">
\begin{equation*}
\label{eqn:7.5}
B^{i, j}_\lambda = \left\{a\in A: \sup(N_i\cap a)&lt;f^\lambda_{\sup(N_j\cap\lambda)}(a)\right\}
\end{equation*}
</div>
<div class="para">is a generator for <span class="process-math">\(\lambda\text{,}\)</span> and</div>
<div class="displaymath process-math">
\begin{equation*}
B^{i, j}_\lambda\subseteq B^*_\lambda.
\end{equation*}
</div>
</div>
<div class="para" id="a-naive-attempt-10">Our plan is to show that the smoothing of <span class="process-math">\(\langle B^*_\lambda:\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\rangle\)</span> produces a transitive sequence of generators, and then show that these reflect nicely down into <span class="process-math">\(N\text{.}\)</span>
</div></section><section class="subsection" id="existence-of-transitive-generators"><h3 class="heading hide-type">
<span class="type">Subsection</span><span class="space"> </span><span class="codenumber">4.3</span><span class="space"> </span><span class="title">Existence of Transitive Generators</span>
</h3>
<div class="para" id="existence-of-transitive-generators-2">
<dfn class="terminology">Theorem 8</dfn>.  <em class="emphasis">Suppose that <span class="process-math">\(A\)</span> is a set a regular cardinals with <span class="process-math">\(|A|^+&lt;\min(A)\text{,}\)</span> and let <span class="process-math">\(N\)</span> be a <span class="process-math">\(\kappa\)</span>-internally approachable model with <span class="process-math">\(A\in N\)</span> for some regular <span class="process-math">\(\kappa\)</span> satisfying <span class="process-math">\(|A|&lt;\kappa&lt;\min(A)\text{.}\)</span> Then there is a transitive sequence <span class="process-math">\(\langle B^\dagger_\lambda:\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\rangle\)</span> of generators for <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(A)\text{.}\)</span> Furthermore, this sequence reflects into <span class="process-math">\(N\text{,}\)</span> in the sense that for each <span class="process-math">\(\zeta&lt;\kappa\text{,}\)</span> there is a transitive sequence <span class="process-math">\(\langle B^\zeta_\lambda:\lambda\in N_\zeta\cap\mathop{\mathrm{pcf}}(A)\rangle\)</span> in <span class="process-math">\(N\)</span> such that <span class="process-math">\(B^\zeta_\lambda\text{,}\)</span> and <span class="process-math">\(B^\zeta_\lambda\subseteq B^\dagger_\lambda\text{.}\)</span></em>
</div>
<div class="para" id="existence-of-transitive-generators-3">The use of the “dagger” is because it looks like a “t”, so it helps to remember that these are transitive.</div>
<div class="para" id="existence-of-transitive-generators-4">
<em class="emphasis">Proof.</em> For each <span class="process-math">\(\lambda\in\mathop{\mathrm{pcf}}(A)\)</span> and <span class="process-math">\(\alpha&lt;\lambda\text{,}\)</span> we will define functions <span class="process-math">\(f^{\lambda,n}_\alpha\)</span> for <span class="process-math">\(n&lt;\omega\)</span> by induction. We start by setting <span class="process-math">\(f^{\lambda,0}_\alpha = f^\lambda_\alpha\text{.}\)</span> For the successor case, we define <span class="process-math">\(f^{\lambda,
n+1}_\alpha\in\prod A\)</span> by</div>
<div class="para logical" id="existence-of-transitive-generators-5"><div class="displaymath process-math">
\begin{equation*}
\label{eqn:7.4}
f^{\lambda, n+1}_\alpha(\theta)=\sup\left[\{f^{\lambda,n}_\alpha(\theta)\}\cup\{f^{\mu,n}_{f^{\lambda,n}_\alpha(\mu)}(\theta):\mu\in
A\cap [\theta,\lambda)\}\right].
\end{equation*}
</div></div>
<div class="para logical" id="existence-of-transitive-generators-6">
<div class="para">This formula deserves some explanation. What we are trying to do is to mirror the smoothing process for <span class="process-math">\(\langle
B^*_\lambda:\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\rangle\)</span> with the cofinality sequences we use to build those generators. Think now for a moment about what occurs if <span class="process-math">\(\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\text{,}\)</span> <span class="process-math">\(\mu\in B^*_\lambda\text{,}\)</span> and <span class="process-math">\(\theta\in B^*_\mu\text{.}\)</span> By definition, this means</div>
<div class="displaymath process-math">
\begin{equation*}
f^\lambda_{\sup(N\cap\lambda)}(\mu) = \sup(N\cap\mu),
\end{equation*}
</div>
<div class="para">and</div>
<div class="displaymath process-math">
\begin{equation*}
f^\mu_{\sup(N\cap\mu)}(\theta) = \sup(N\cap\theta).
\end{equation*}
</div>
<div class="para">But then</div>
<div class="displaymath process-math">
\begin{equation*}
\sup(N\cap\theta)=f^\mu_{\sup(N\cap\mu)}(\theta) = f^\mu_{f^\lambda_{\sup(N\cap\lambda)}(\mu)}(\theta)\leq f^{\lambda, 1}_{\sup(N\cap\lambda)}(\theta).
\end{equation*}
</div>
<div class="para">On the other hand, since <span class="process-math">\(\bar{f}^\lambda\)</span> and <span class="process-math">\(\bar{f}^\mu\)</span> are both minimally club continuous at cofinality <span class="process-math">\(\kappa\text{,}\)</span> it will follow (and we shall soon show) that</div>
<div class="displaymath process-math">
\begin{equation*}
f^{\lambda, 1}_{\sup(N\cap\lambda)}\leq \chi_N.
\end{equation*}
</div>
<div class="para">Thus,</div>
<div class="displaymath process-math">
\begin{equation*}
B^*_\lambda\cup\bigcup\{B^*_\mu:\mu\in B^*_\lambda\}\subseteq \left\{a\in A: \sup(N\cap a) = f^{\lambda, 1}_{\sup(N\cap\lambda)}(a)\right\},
\end{equation*}
</div>
<div class="para">and we will be able to use arguments from the previous section to prove the set on the right is still a generator for <span class="process-math">\(\lambda\text{.}\)</span>
</div>
</div>
<div class="para" id="existence-of-transitive-generators-7">Let’s do this formally. First, we denote the smoothing process as before:</div>
<div class="para logical" id="existence-of-transitive-generators-8"><ul class="disc">
<li id="existence-of-transitive-generators-8-1-1"><div class="para" id="existence-of-transitive-generators-8-1-1-1">
<span class="process-math">\(B^0_\lambda = B^*_\lambda\text{,}\)</span> and</div></li>
<li id="existence-of-transitive-generators-8-1-2"><div class="para" id="existence-of-transitive-generators-8-1-2-1">
<span class="process-math">\(B^{n+1}_\lambda = B^n_\lambda\cup\bigcup\{B^n_\mu:\mu\in B^n_\lambda\}\text{,}\)</span> and</div></li>
<li id="existence-of-transitive-generators-8-1-3"><div class="para" id="existence-of-transitive-generators-8-1-3-1"><span class="process-math">\(B^\dagger_\lambda = \bigcup_{n&lt;\omega} B^n_\lambda\text{.}\)</span></div></li>
</ul></div>
<div class="para logical" id="existence-of-transitive-generators-9">
<div class="para">We show by induction on <span class="process-math">\(n&lt;\omega\)</span> that the following statements hold for all <span class="process-math">\(\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\text{:}\)</span>
</div>
<div class="displaymath process-math">
\begin{equation*}
\label{eqn:7.1}
B^{n}_\lambda\subseteq\left\{a\in A: \sup(N\cap a) = f^{\lambda, n}_{\sup(N\cap\lambda)}(a)\right\}.
\end{equation*}
</div>
<div class="para">and</div>
<div class="displaymath process-math">
\begin{equation*}
\label{eqn:7.2}
\gamma\in\mathop{\mathrm{cl}}(N)\cap\lambda\Longrightarrow \mathop{\mathrm{ran}}(f^{\lambda, n}_\gamma)\subseteq\mathop{\mathrm{cl}}(N),
\end{equation*}
</div>
<div class="para">where “<span class="process-math">\(\mathop{\mathrm{cl}}(N)\)</span>” denotes the closure of <span class="process-math">\(N\cap\mathop{\mathrm{Ord}}\)</span> in the order-topology.</div>
</div>
<div class="para logical" id="existence-of-transitive-generators-10">
<div class="para">The first statement is true for <span class="process-math">\(n = 0\)</span> by our choice of <span class="process-math">\(B^*_\lambda\text{.}\)</span> For the second statement, we have what we need automatically if <span class="process-math">\(\gamma\)</span> is in <span class="process-math">\(N\text{,}\)</span> as then <span class="process-math">\(\mathop{\mathrm{ran}}(f^\lambda_\gamma)\)</span> will be a subset of <span class="process-math">\(N\text{.}\)</span> If <span class="process-math">\(\gamma = \sup(N\cap\gamma)\)</span> but <span class="process-math">\(\gamma\notin N\text{,}\)</span> then we know <span class="process-math">\(\mathop{\mathrm{cf}}(\gamma) = \kappa\)</span> and by the minimal club continuity requirement</div>
<div class="displaymath process-math" data-contains-math-knowls=" ">
\begin{equation*}
f^\lambda_\gamma = \sup\{f^\lambda_\alpha:\alpha\in C\}
\end{equation*}
</div>
<div class="para">for some closed unbounded <span class="process-math">\(C\subseteq N\cap\gamma\text{.}\)</span> Since the range of <span class="process-math">\(f^\lambda_\alpha\)</span> is a subset of <span class="process-math">\(N\)</span> for <span class="process-math">\(\alpha\in C\text{,}\)</span> we have what we need. Now assume (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.1" missing or not unique]</code>) and (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.2" missing or not unique]</code>) hold for <span class="process-math">\(n\)</span> and all <span class="process-math">\(\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\text{.}\)</span>
</div>
</div>
<div class="para logical" id="existence-of-transitive-generators-11">
<div class="para">Since <span class="process-math">\(f^{\lambda, n}_\alpha\leq f^{\lambda, n+1}_\alpha\)</span> for all <span class="process-math">\(\alpha&lt;\lambda\text{,}\)</span> we will need to show</div>
<div class="displaymath process-math">
\begin{equation*}
\theta\in B^{n+1}_\lambda\setminus B^n_\lambda \Longrightarrow \sup(N\cap\theta)\leq f^{\lambda, n+1}_{\sup(N\cap\lambda)}(\theta).
\end{equation*}
</div>
<div class="para">For such a <span class="process-math">\(\theta\text{,}\)</span> there is a <span class="process-math">\(\mu\in B^n_\lambda\)</span> with <span class="process-math">\(\theta\in B^n_\mu\)</span> and by our induction hypothesis this means</div>
<div class="displaymath process-math">
\begin{equation*}
\sup(N\cap\theta)\leq f^{\mu, n}_{\sup(N\cap\mu)}(\theta).
\end{equation*}
</div>
<div class="para">Thus, we have part of what we need:</div>
<div class="displaymath process-math">
\begin{equation*}
\label{eqn:7.3}
\sup(N\cap\theta)\leq f^{\mu, n}_{\sup(N\cap\mu)}(\theta) = f^{\mu, n}_{f^{\lambda, n}_{\sup(N\cap\lambda)}(\mu)}(\theta)\leq f^{\lambda, n+1}_{\sup(N\cap\lambda)}(\theta).
\end{equation*}
</div>
</div>
<div class="para logical" id="existence-of-transitive-generators-12">
<div class="para">Now look at (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.2" missing or not unique]</code>). Given <span class="process-math">\(\gamma\in\mathop{\mathrm{cl}}(N)\cap\lambda\text{,}\)</span> the value of <span class="process-math">\(f^{\lambda,n+1}_\gamma(\theta)\)</span> is computed as the supremum of a certain set, so we need to check that each element of this set is in the closure of <span class="process-math">\(N\text{.}\)</span> This is true for <span class="process-math">\(f^{\lambda, n}_\gamma(\theta)\)</span> by our induction hypothesis. If <span class="process-math">\(\mu\in A\cap [\theta,\lambda)\text{,}\)</span> then <span class="process-math">\(f^{\lambda, n}_\gamma(\mu)\)</span> will be in the closure of <span class="process-math">\(N\)</span> by our induction hypothesis for <span class="process-math">\(\lambda\text{,}\)</span> and so</div>
<div class="displaymath process-math" data-contains-math-knowls=" ">
\begin{equation*}
f^{\mu, n}_{f^{\lambda, n}_{\sup(N\cap\lambda)}}(\theta)\in\mathop{\mathrm{cl}}(N)
\end{equation*}
</div>
<div class="para">by our induction hypothesis for <span class="process-math">\(\mu\text{.}\)</span> Thus, (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.2" missing or not unique]</code>) will continue to hold.</div>
</div>
<div class="para logical" id="existence-of-transitive-generators-13">
<div class="para">From this, we conclude</div>
<div class="displaymath process-math" data-contains-math-knowls=" ">
\begin{equation*}
f^{\lambda, n+1}_{\sup(N\cap\lambda)}(\theta)\leq\max(\mathop{\mathrm{cl}}(N)\cap\theta)=\sup(N\cap\theta),
\end{equation*}
</div>
<div class="para">and combining this with (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.3" missing or not unique]</code>) gives us (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.1" missing or not unique]</code>).</div>
</div>
<div class="para" id="existence-of-transitive-generators-14">We emphasize that the (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.1" missing or not unique]</code>) and (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.2" missing or not unique]</code>) are facts that are external to the model <span class="process-math">\(N\text{.}\)</span> Outside of the model, we see that these statements are true, and that they hold only for those <span class="process-math">\(\lambda\)</span> that are in <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(A)\text{.}\)</span> On the other hand, the actual construction of the functions is done for all <span class="process-math">\(\lambda\in\mathop{\mathrm{pcf}}(A)\)</span> and <span class="process-math">\(\alpha&lt;\lambda\)</span> using the recipe (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.4" missing or not unique]</code>), and this is something that the model <span class="process-math">\(N\)</span> sees.</div>
<div class="para logical" id="existence-of-transitive-generators-15">
<div class="para">Thus, if for each <span class="process-math">\(\lambda\in\mathop{\mathrm{pcf}}(A)\)</span> and <span class="process-math">\(\alpha&lt;\lambda\)</span> we define</div>
<div class="displaymath process-math">
\begin{equation*}
f^{\lambda,\omega}_\alpha = \sup\{f^{\lambda, n}_\alpha:n&lt;\omega\},
\end{equation*}
</div>
<div class="para">the resulting collection <span class="process-math">\(\langle f^{\lambda,\omega}_\alpha:\lambda\in \mathop{\mathrm{pcf}}(A)\text{ and }\alpha&lt;\lambda\rangle\)</span> is in <span class="process-math">\(N\text{.}\)</span> We will use this to prove that <span class="process-math">\(\max\mathop{\mathrm{pcf}}(B^\dagger_\lambda)=\lambda\)</span> for each <span class="process-math">\(\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\text{.}\)</span>
</div>
</div>
<div class="para" id="existence-of-transitive-generators-16">This is an argument we used before when we showed that <span class="process-math">\(B^*_\lambda\)</span> is a generator. It goes through under fairly general circumstances but we won’t belabor that now.</div>
<div class="para logical" id="existence-of-transitive-generators-17">
<div class="para">We need only consider the case where <span class="process-math">\(\lambda&lt;\max\mathop{\mathrm{pcf}}(A)\text{.}\)</span> In this situation, we can find a <span class="process-math">\(g\in\prod A\)</span> <em class="emphasis">in</em>  <span class="process-math">\(N\)</span> that bounds <span class="process-math">\(\langle f^{\lambda,\omega}_\alpha:\alpha&lt;\lambda\rangle\)</span> modulo <span class="process-math">\(J_{\leq\lambda}[A]\)</span> because the corresponding reduced product is <span class="process-math">\(\lambda^+\)</span>-directed. Our construction guarantees that for <span class="process-math">\(\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\)</span> we will have</div>
<div class="displaymath process-math">
\begin{equation*}
B^\dagger_\lambda\subseteq\{ a\in A: f^{\lambda,\omega}_{\sup(N\cap\lambda)}(a) = \sup(N\cap a)\}.
\end{equation*}
</div>
<div class="para">Since the function <span class="process-math">\(g\)</span> is in <span class="process-math">\(N\text{,}\)</span> we have</div>
<div class="displaymath process-math">
\begin{equation*}
\{a\in A: f^{\lambda,\omega}_{\sup(N\cap\lambda)}(a) = \sup(N\cap a)\}\subseteq \{a\in A: g(a)&lt;
f^{\lambda,\omega}_{\sup(N\cap\lambda)}(a)\},
\end{equation*}
</div>
<div class="para">and this last set is in <span class="process-math">\(J_{\leq\lambda}[A]\)</span> by our choice of <span class="process-math">\(g\text{.}\)</span> Thus, <span class="process-math">\(\max\mathop{\mathrm{pcf}}(B^\dagger_\lambda)\leq\lambda\text{,}\)</span> and <span class="process-math">\(\langle B^\dagger:\lambda\in\mathop{\mathrm{pcf}}(A)\rangle\)</span> is a transitive sequence of generators for <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(A)\text{.}\)</span>
</div>
</div>
<div class="para logical" id="existence-of-transitive-generators-18">
<div class="para">We still have unfulfilled promises concerning the ability to reflect this sequence of generators into <span class="process-math">\(N\text{,}\)</span> and for this we need to use the closed unbounded set <span class="process-math">\(E\)</span> and generators <span class="process-math">\(B^{i,j}_\lambda\)</span> from (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.5" missing or not unique]</code>). Given <span class="process-math">\(\zeta&lt;\kappa\text{,}\)</span> since <span class="process-math">\(|N_\zeta\cap\mathop{\mathrm{pcf}}(A)|&lt;\kappa\)</span> we can find <span class="process-math">\(i&lt;j\)</span> in <span class="process-math">\(E\)</span> so large that for all <span class="process-math">\(\lambda\in N_\zeta\cap\mathop{\mathrm{pcf}}(A)\rangle\text{,}\)</span>
</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
B^{i,j}_\lambda = \left\{a\in A: \sup(N_i\cap a)&lt;f^{\lambda}_{\sup(N_j\cap\lambda)}(a)\right\}
\end{equation*}
</div>
<div class="para">is a generator for <span class="process-math">\(\lambda\)</span> that is a subset of <span class="process-math">\(B^*_\lambda\text{.}\)</span> The entire collection <span class="process-math">\(\langle B^{i,j}_\lambda:\lambda\in N_\zeta\cap\mathop{\mathrm{pcf}}(A)\rangle\)</span> is in <span class="process-math">\(N_{j+1}\text{.}\)</span> If we run the smoothing process on this collection, the corresponding sequence <span class="process-math">\(\langle B^\zeta_\lambda:\lambda\in N_\zeta\cap\mathop{\mathrm{pcf}}(A)\rangle\)</span> is also in <span class="process-math">\(N_{j+1}\text{,}\)</span> and since <span class="process-math">\(B^{i,j}_\lambda\subseteq B^*_\lambda\text{,}\)</span> we have</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
B^\zeta_{\lambda}\subseteq B^{\dagger}_\lambda.
\end{equation*}
</div>
<div class="para">Thus, <span class="process-math">\(\langle B^\zeta_\lambda:\lambda\in N_\zeta\cap\mathop{\mathrm{pcf}}(A)\rangle\)</span> is a transitive sequence of generators for <span class="process-math">\(N_\zeta\cap\mathop{\mathrm{pcf}}(A)\)</span> that is in the model <span class="process-math">\(N\text{.}\)</span> ◻</div>
</div></section><section class="subsection" id="the-localization-theorem"><h3 class="heading hide-type">
<span class="type">Subsection</span><span class="space"> </span><span class="codenumber">4.4</span><span class="space"> </span><span class="title">The Localization Theorem</span>
</h3>
<div class="para logical" id="the-localization-theorem-2">
<div class="para">We know that a full collection <span class="process-math">\(\langle B_\lambda:\lambda\in\mathop{\mathrm{pcf}}(A)\rangle\)</span> of generators for <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\)</span> possesses a nice compactness property: if <span class="process-math">\(B\subseteq A\)</span> then there is a finite collection <span class="process-math">\(\lambda_0&gt;\dots&gt;\lambda_n\)</span> of cardinals in <span class="process-math">\(\mathop{\mathrm{pcf}}(B)\)</span> such that</div>
<div class="displaymath process-math">
\begin{equation*}
B\subseteq B_{\lambda_0}\cup\dots\cup B_{\lambda_n}.
\end{equation*}
</div>
</div>
<div class="para" id="the-localization-theorem-3">The situation is a little more delicate if we don’t have a full suite of generators at our disposal, and this state of affairs may arise in situations where we want to make arguments using transitive generators because Theorem <code class="code-inline tex2jax_ignore">[cross-reference to target(s) "thm:TransGenExist" missing or not unique]</code> only provides transitive generators for <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(A)\)</span> which is not guaranteed to include everything. The following lemma tell us that the transitive generators we build for <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(A)\)</span> will suffice to cover a set <span class="process-math">\(B\subseteq A\text{,}\)</span> as long as we know <span class="process-math">\(B\)</span> is in <span class="process-math">\(N\text{.}\)</span>
</div>
<div class="para" id="the-localization-theorem-4">The following argument should look familiar by this point:</div>
<div class="para logical" id="the-localization-theorem-5">
<div class="para">
<dfn class="terminology">Lemma 20</dfn>.  Suppose <span class="process-math">\(B\)</span> is a subset of <span class="process-math">\(A\)</span> and <span class="process-math">\(B\in N\text{.}\)</span> Then there is a finite collection <span class="process-math">\(\lambda_0&gt;\dots&gt;\lambda_n\)</span> of cardinals in <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(B)\)</span> such that</div>
<div class="displaymath process-math">
\begin{equation*}
B\subseteq B^\dagger_{\lambda_0}\cup\dots\cup B^\dagger_{\lambda_n}.
\end{equation*}
</div>
</div>
<div class="para" id="the-localization-theorem-6">
<em class="emphasis">Proof.</em> For each <span class="process-math">\(\lambda\in N\cap\mathop{\mathrm{pcf}}(A)\text{,}\)</span> let <span class="process-math">\(B'_\lambda\)</span> be an internal reflection of <span class="process-math">\(B^\dagger_\lambda\)</span> in <span class="process-math">\(N\text{,}\)</span> that is,</div>
<div class="para logical" id="the-localization-theorem-7"><ul class="disc">
<li id="the-localization-theorem-7-1-1"><div class="para" id="the-localization-theorem-7-1-1-1">
<span class="process-math">\(B'_\lambda\)</span> is a generator for <span class="process-math">\(\lambda\text{,}\)</span>
</div></li>
<li id="the-localization-theorem-7-1-2"><div class="para" id="the-localization-theorem-7-1-2-1">
<span class="process-math">\(B'\in N\text{,}\)</span> and</div></li>
<li id="the-localization-theorem-7-1-3"><div class="para" id="the-localization-theorem-7-1-3-1"><span class="process-math">\(B'_\lambda\subseteq B^\dagger_\lambda\text{.}\)</span></div></li>
</ul></div>
<div class="para logical" id="the-localization-theorem-8">
<div class="para">Since <span class="process-math">\(B\in N\text{,}\)</span> we know <span class="process-math">\(\lambda_0 = \max\mathop{\mathrm{pcf}}(B)\)</span> is in <span class="process-math">\(N\)</span> too, as well as</div>
<div class="displaymath process-math">
\begin{equation*}
B_1 = B\setminus B'_{\lambda_0}.
\end{equation*}
</div>
<div class="para">Furthermore, if <span class="process-math">\(B_1\)</span> is non-empty, then <span class="process-math">\(\lambda_1=\max\mathop{\mathrm{pcf}}(B_1)\)</span> is in <span class="process-math">\(N\text{,}\)</span> and <span class="process-math">\(\lambda_1&lt;\lambda_0\text{.}\)</span> Now we iterate this process just as in previous arguments o produce <span class="process-math">\(\lambda_0&gt;\dots&gt;\lambda_n\)</span> in <span class="process-math">\(\mathop{\mathrm{pcf}}(B)\cap N\)</span> such that</div>
<div class="displaymath process-math">
\begin{equation*}
B\subseteq B'_{\lambda_0}\cup\dots\cup B'_{\lambda_n}.
\end{equation*}
</div>
<div class="para">Since the primed generators are reflections of the transitive generators we started with, we have</div>
<div class="displaymath process-math">
\begin{equation*}
B\subseteq B^\dagger_{\lambda_0}\cup\dots\cup B^\dagger_{\lambda_n}
\end{equation*}
</div>
<div class="para">as required. ◻</div>
</div>
<div class="para" id="the-localization-theorem-9">We will use this to prove one of the important structural results about <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\text{.}\)</span> We borrow the language below from topology.</div>
<div class="para logical" id="the-localization-theorem-10">
<div class="para">
<dfn class="terminology">Definition 21</dfn>.  A set <span class="process-math">\(B\subseteq \mathop{\mathrm{pcf}}(A)\)</span> is <em class="emphasis">left separated</em> if</div>
<div class="displaymath process-math">
\begin{equation*}
\theta\in B\Longrightarrow \max\mathop{\mathrm{pcf}}(B\cap\theta)&lt;\theta.
\end{equation*}
</div>
</div>
<div class="para" id="the-localization-theorem-11">Left separated subsets of <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\)</span> should be thought of as “thin” or “rapidly growing”. The next result shows us that these cannot be too large.</div>
<div class="para" id="the-localization-theorem-12">
<dfn class="terminology">Theorem 9</dfn>.  <em class="emphasis">Let <span class="process-math">\(A\)</span> be a progressive set of regular cardinals. If <span class="process-math">\(B\subseteq\mathop{\mathrm{pcf}}(A)\)</span> is left separated, then <span class="process-math">\(|B|\leq |A|\text{.}\)</span></em>
</div>
<div class="para" id="the-localization-theorem-13">
<em class="emphasis">Proof.</em> By way of contradiction, assume that <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\)</span> has a left separated subset <span class="process-math">\(B\)</span> of cardinality <span class="process-math">\(|A|^+\text{.}\)</span> We may assume without loss of generality that <span class="process-math">\(|A|^{++}&lt;\min(A)\text{,}\)</span> and let <span class="process-math">\(A'\)</span> denote <span class="process-math">\(A\cup B\)</span> and <span class="process-math">\(\kappa\)</span> denote <span class="process-math">\(|A|^{++}\text{.}\)</span>
</div>
<div class="para" id="the-localization-theorem-14">Let <span class="process-math">\(N\)</span> be a <span class="process-math">\(\kappa\)</span>-internally approachable model containing <span class="process-math">\(A'\text{,}\)</span> and let <span class="process-math">\(\langle B^\dagger_\lambda:\lambda\in N\cap\mathop{\mathrm{pcf}}(A')\rangle\)</span> be the transitive sequence of generators for <span class="process-math">\(N\cap\mathop{\mathrm{pcf}}(A')\)</span> obtained from Theorem <code class="code-inline tex2jax_ignore">[cross-reference to target(s) "thm:TransGenExist" missing or not unique]</code>.</div>
<div class="para" id="the-localization-theorem-15">Since <span class="process-math">\(B\subseteq\mathop{\mathrm{pcf}}(A)\text{,}\)</span> for each <span class="process-math">\(\theta\in B\)</span> we know <span class="process-math">\(\theta\in\mathop{\mathrm{pcf}}(B_\theta^\dagger\cap A)\)</span> – in fact, <span class="process-math">\(\theta\)</span> is <span class="process-math">\(\max\mathop{\mathrm{pcf}}(B^\dagger_\theta\cap A)\text{.}\)</span>
</div>
<div class="para logical" id="the-localization-theorem-16">
<div class="para">On the other hand, there is a <span class="process-math">\(\lambda\in B\)</span> such that</div>
<div class="displaymath process-math">
\begin{equation*}
A\cap\bigcup_{\theta\in B}B_\theta^\dagger = A\cap\bigcup_{\theta\in B\cap\lambda}B_\theta.
\end{equation*}
</div>
</div>
<div class="para" id="the-localization-theorem-17">For each <span class="process-math">\(a\in A\text{,}\)</span> we ask if <span class="process-math">\(a\in B^\dagger_\theta\)</span> for some <span class="process-math">\(\theta\in B\text{.}\)</span> The answer to this may be either “yes” or “no”, but since <span class="process-math">\(|B|=|A|^+\text{,}\)</span> there is a <span class="process-math">\(\lambda\in B\)</span> so that if the answer is “yes” for <span class="process-math">\(a\text{,}\)</span> then there is such a <span class="process-math">\(\theta&lt;\lambda\text{.}\)</span>
</div>
<div class="para" id="the-localization-theorem-18">(Think of this topologically – <span class="process-math">\(B_\theta\)</span> should be visualized as an open neighborhood of <span class="process-math">\(\theta\text{,}\)</span> with <span class="process-math">\(A\)</span> playing the role of a dense subset of <span class="process-math">\(A'\text{.}\)</span> We are looking at those members of <span class="process-math">\(A\)</span> that are covered by the <span class="process-math">\(B_\theta\text{,}\)</span> and then it is clear that such a <span class="process-math">\(\lambda\)</span> must exist. Since <span class="process-math">\(|A|&lt;|B|\text{,}\)</span> there is a <span class="process-math">\(\lambda\in B\)</span> such that part of <span class="process-math">\(A\)</span> that is covered by some <span class="process-math">\(B^\dagger_\theta\)</span> with <span class="process-math">\(\theta\in B\)</span> must be covered by <span class="process-math">\(B_\theta^\dagger\)</span> for some <span class="process-math">\(\theta&lt;\lambda\text{.}\)</span>)</div>
<div class="para" id="the-localization-theorem-19">(Let <span class="process-math">\(A^*\)</span> be the part of <span class="process-math">\(A\)</span> that is covered by <span class="process-math">\(B_\theta^\dagger\)</span> for some <span class="process-math">\(\theta\in B\text{.}\)</span> We now know two facts:</div>
<div class="para logical" id="the-localization-theorem-20"><ul class="disc">
<li id="the-localization-theorem-20-1-1"><div class="para" id="the-localization-theorem-20-1-1-1">
<span class="process-math">\(B\subseteq\mathop{\mathrm{pcf}}(A^*)\text{,}\)</span> and</div></li>
<li id="the-localization-theorem-20-1-2"><div class="para" id="the-localization-theorem-20-1-2-1">there is a <span class="process-math">\(\lambda\in B\)</span> such that <span class="process-math">\(A^*\subseteq \bigcup \{B^\dagger_\theta:\theta\in B\cap\lambda\}\)</span>
</div></li>
</ul></div>
<div class="para" id="the-localization-theorem-21">We will get a contradiction by showing that <span class="process-math">\(\max\mathop{\mathrm{pcf}}(A^*)&lt;\lambda\text{.}\)</span> )</div>
<div class="para logical" id="the-localization-theorem-22">
<div class="para">Now let <span class="process-math">\(C = B\cap \lambda\text{.}\)</span> Since <span class="process-math">\(C\)</span> is in <span class="process-math">\(N\text{,}\)</span> we can apply Lemma <code class="code-inline tex2jax_ignore">[cross-reference to target(s) "lem:ComForTrans" missing or not unique]</code> and find <span class="process-math">\(\lambda_0&gt;\dots&gt;\lambda_n\)</span> in <span class="process-math">\(\mathop{\mathrm{pcf}}(C)\cap N\)</span> such that</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
C\subseteq B^\dagger_{\lambda_0}\cup\dots\cup B^\dagger_{\lambda_n}.
\end{equation*}
</div>
</div>
<div class="para logical" id="the-localization-theorem-23">
<div class="para">Since <span class="process-math">\(B\)</span> is left separated, we know <span class="process-math">\(\max\mathop{\mathrm{pcf}}(C)&lt;\lambda\)</span> and hence</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
\label{eqn:7.7}
B^\dagger_{\lambda_0}\cup\dots\cup B^\dagger_{\lambda_n}\in J_{&lt;\lambda}[A'].
\end{equation*}
</div>
<div class="para">Now we claim</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
A^*\subseteq B^\dagger_{\lambda_0}\cup\dots\cup B^\dagger_{\lambda_n},
\end{equation*}
</div>
<div class="para">Why does this hold? If <span class="process-math">\(a\in A^*\)</span>  then <span class="process-math">\(a\)</span> is in <span class="process-math">\(B^\dagger_\theta\)</span> for some <span class="process-math">\(\theta\in C\text{.}\)</span> But <span class="process-math">\(\theta\)</span> must be in <span class="process-math">\(B^{\dagger}_{\lambda_i}\)</span> for some <span class="process-math">\(i\leq n\)</span> so by transitivity</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
a\in B^\dagger_\theta\subseteq B^\dagger_{\lambda_i}
\end{equation*}
</div>
<div class="para">and we have (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.6" missing or not unique]</code>).</div>
</div>
<div class="para logical" id="the-localization-theorem-24">
<div class="para">But now we have a contradiction, as on the one hand (<code class="code-inline tex2jax_ignore">[cross-reference to target(s) "eqn:7.7" missing or not unique]</code>) tells us</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
A^*\in J_{&lt;\lambda}[A\cup B],
\end{equation*}
</div>
<div class="para">and on the other hand</div>
<div class="displaymath process-math" data-contains-math-knowls="">
\begin{equation*}
\lambda\in\mathop{\mathrm{pcf}}(A^*).
\end{equation*}
</div>
<div class="para"> ◻</div>
</div>
<div class="para" id="the-localization-theorem-25">The next theorem is really just another translation of the bound we have on left-separated subspaces in <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\text{.}\)</span> It says that <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\)</span> satisfies a modified topological tightness condition.</div>
<div class="para" id="the-localization-theorem-26">
<dfn class="terminology">Theorem 10</dfn> (Localization).  <em class="emphasis">Suppose <span class="process-math">\(A\)</span> is progressive set of regular cardinals, and <span class="process-math">\(B\subseteq\mathop{\mathrm{pcf}}(A)\)</span> is progressive. If <span class="process-math">\(\lambda\in\mathop{\mathrm{pcf}}(B)\)</span> then there exists a set <span class="process-math">\(C\subseteq B\)</span> such that<div class="displaymath process-math">
\begin{equation*}
|C|\leq |B|,
\end{equation*}
</div>and<div class="displaymath process-math">
\begin{equation*}
\lambda\in\mathop{\mathrm{pcf}}(C).
\end{equation*}
</div></em>
</div>
<div class="para" id="the-localization-theorem-27">
<em class="emphasis">Proof.</em> Suppose <span class="process-math">\(B\subseteq \mathop{\mathrm{pcf}}(A)\)</span> with <span class="process-math">\(|B|&lt;\min(B)\text{.}\)</span> We prove the result by induction on <span class="process-math">\(\lambda\in\mathop{\mathrm{pcf}}(B)\text{,}\)</span> so assume we have the result for all <span class="process-math">\(\theta\in\mathop{\mathrm{pcf}}(B)\cap\lambda\text{.}\)</span> It suffices to produce a subset <span class="process-math">\(C\)</span> of <span class="process-math">\(\mathop{\mathrm{pcf}}(B)\cap\lambda\)</span> with <span class="process-math">\(\lambda\in C\)</span> and <span class="process-math">\(|C|\leq|A|\text{,}\)</span> as for each <span class="process-math">\(\theta\in C\text{,}\)</span> our induction assumption will had us a set <span class="process-math">\(C_\theta\subseteq B\)</span> such that <span class="process-math">\(|C_\theta|\leq |A|\)</span> and <span class="process-math">\(\theta\in\mathop{\mathrm{pcf}}(C_\theta)\text{.}\)</span> The union of the sets <span class="process-math">\(C_\theta\)</span> is a subset of <span class="process-math">\(B\)</span> of cardinality at most <span class="process-math">\(|A|\)</span> that picks up <span class="process-math">\(\lambda\)</span> as a possible cofinality.</div>
<div class="para" id="the-localization-theorem-28">We can also make some simplifying assumptions by passing to suitable subsets of <span class="process-math">\(B\text{.}\)</span> For example, we may assume that <span class="process-math">\(\lambda = \max\mathop{\mathrm{pcf}}(B)\text{,}\)</span> and <span class="process-math">\(\mathop{\mathrm{pcf}}(B)\cap\lambda\)</span> has no last element. This can be arranged by first replacing <span class="process-math">\(B\)</span> by <span class="process-math">\(B_\lambda[B]\)</span> (to make sure that <span class="process-math">\(\lambda\)</span> is the maximum possible cofinality), and then asking if <span class="process-math">\(\mathop{\mathrm{pcf}}(B)\cap\lambda\)</span> has a maximum value. If so, we remove a generator for that value, and ask the question again. We cannot answer “yes” infinitely many times, as this would produce an infinite decreasing sequence of cardinals. But the union of the finitely many sets we remove by this process is in <span class="process-math">\(J_{&lt;\lambda}[B]\text{,}\)</span> so <span class="process-math">\(\lambda\)</span> will still be the maximum possible cofinality of the remainder.</div>
<div class="para logical" id="the-localization-theorem-29">
<div class="para">We will build our set <span class="process-math">\(C\)</span> through a construction that will attempt to pass through <span class="process-math">\(|A|^+\)</span> levels, adding some <span class="process-math">\(\theta_\alpha\)</span> into <span class="process-math">\(C\)</span> at stage <span class="process-math">\(\alpha\text{.}\)</span> We try to make sure that <span class="process-math">\(\theta_\alpha\)</span> is in <span class="process-math">\(\mathop{\mathrm{pcf}}(B)\text{,}\)</span> and that</div>
<div class="displaymath process-math">
\begin{equation*}
\max\mathop{\mathrm{pcf}}(\{\theta_\beta:\beta&lt;\alpha\})&lt;\theta_\alpha&lt;\lambda.
\end{equation*}
</div>
<div class="para">This construction cannot continue for all <span class="process-math">\(|A|^+\)</span> stages, as it would generate a left-separated subset of <span class="process-math">\(\mathop{\mathrm{pcf}}(A)\)</span> of cardinality <span class="process-math">\(|A|^+\text{.}\)</span> So this means we reach a stage <span class="process-math">\(\alpha\)</span> where there is no suitable <span class="process-math">\(\theta_\alpha\text{.}\)</span> We have arranged that <span class="process-math">\(\mathop{\mathrm{pcf}}(B)\cap\lambda\)</span> does not have a maximum element, so the only way that we fail to find an appropriate <span class="process-math">\(\theta_\alpha\)</span> is if</div>
<div class="displaymath process-math">
\begin{equation*}
\lambda\in\mathop{\mathrm{pcf}}(\{\theta_\beta:\beta&lt;\alpha\}).
\end{equation*}
</div>
<div class="para">But now we define</div>
<div class="displaymath process-math">
\begin{equation*}
C:=\{\theta_\beta:\beta&lt;\alpha\}
\end{equation*}
</div>
<div class="para">and we are done. ◻</div>
</div></section></section></div>
<div class="ptx-content-footer">
<a class="previous-button button" href="things-we-already-know.html" title="Previous"><span class="icon material-symbols-outlined" aria-hidden="true">&#xe5cb;</span><span class="name">Prev</span></a><a class="top-button button" href="#" title="Top"><span class="icon material-symbols-outlined" aria-hidden="true">&#xe5ce;</span><span class="name">Top</span></a><a class="next-button button" href="no-large-intervals.html" title="Next"><span class="name">Next</span><span class="icon material-symbols-outlined" aria-hidden="true">&#xe5cc;</span></a>
</div></main>
</div>
<div id="ptx-page-footer" class="ptx-page-footer">
<a class="pretext-link" href="https://pretextbook.org" title="PreTeXt"><div class="logo"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="338 3000 8772 6866"><g style="stroke-width:.025in; stroke:black; fill:none"><polyline points="472,3590 472,9732 " style="stroke:#000000;stroke-width:174; stroke-linejoin:miter; stroke-linecap:round; "></polyline><path style="stroke:#000000;stroke-width:126;stroke-linecap:butt;" d="M 4724,9448 A 4660 4660  0  0  1  8598  9259"></path><path style="stroke:#000000;stroke-width:174;stroke-linecap:butt;" d="M 4488,9685 A 4228 4228  0  0  0   472  9732"></path><path style="stroke:#000000;stroke-width:126;stroke-linecap:butt;" d="M 4724,3590 A 4241 4241  0  0  1  8598  3496"></path><path style="stroke:#000000;stroke-width:126;stroke-linecap:round;" d="M 850,3496  A 4241 4241  0  0  1  4724  3590"></path><path style="stroke:#000000;stroke-width:126;stroke-linecap:round;" d="M 850,9259  A 4507 4507  0  0  1  4724  9448"></path><polyline points="5385,4299 4062,8125" style="stroke:#000000;stroke-width:300; stroke-linejoin:miter; stroke-linecap:round;"></polyline><polyline points="8598,3496 8598,9259" style="stroke:#000000;stroke-width:126; stroke-linejoin:miter; stroke-linecap:round;"></polyline><polyline points="850,3496 850,9259" style="stroke:#000000;stroke-width:126; stroke-linejoin:miter; stroke-linecap:round;"></polyline><polyline points="4960,9685 4488,9685" style="stroke:#000000;stroke-width:174; stroke-linejoin:miter; stroke-linecap:round;"></polyline><polyline points="3070,4582 1889,6141 3070,7700" style="stroke:#000000;stroke-width:300; stroke-linejoin:miter; stroke-linecap:round;"></polyline><polyline points="6418,4582 7600,6141 6418,7700" style="stroke:#000000;stroke-width:300; stroke-linejoin:miter; stroke-linecap:round;"></polyline><polyline points="8976,3590 8976,9732" style="stroke:#000000;stroke-width:174; stroke-linejoin:miter; stroke-linecap:round;"></polyline><path style="stroke:#000000;stroke-width:174;stroke-linecap:butt;" d="M 4960,9685 A 4228 4228  0  0  1  8976  9732"></path></g></svg></div></a><a class="runestone-link" href="https://runestone.academy" title="Runestone Academy"><img class="logo" src="https://runestone.academy/runestone/static/images/RAIcon_cropped.png"></a><a class="mathjax-link" href="https://www.mathjax.org" title="MathJax"><img class="logo" src="https://www.mathjax.org/badge/badge-square-2.png"></a>
</div>
</body>
</html>
